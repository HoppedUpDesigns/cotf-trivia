*** this file explains how all the main files of the cotf Quiz App works ***
*** /Users/jason/Sites/cotf is the root folder of the cotf Quiz App ***
//****************************** 1. PROJECT-ROOT-FOLDER/package.json **********************************************************************/
The package.json file for the /Users/jason/Sites/package.json contains the cotf Quiz App configuration, dependencies, and scripts.
Here's a breakdown of the key sections in the PROJECT-ROOT-FOLDER/package.json code file:
{
"name": "COTF-Trivia",
"version": "0.1.0",
"private": true,
"dependencies": {
"@testing-library/jest-dom": "^5.16.5",
"@testing-library/react": "^13.4.0",
"@testing-library/user-event": "^13.5.0",
"@types/jest": "^27.5.2",
"@types/node": "^16.18.12",
"@types/react": "^18.0.28",
"@types/react-dom": "^18.0.11",
"firebase": "^10.7.1",
"prismjs": "^1.29.0",
"react": "^18.2.0",
"react-dom": "^18.2.0",
"react-scripts": "5.0.1",
"styled-components": "^5.3.6",
"typescript": "^4.9.5",
"web-vitals": "^2.1.4"
},
"scripts": {
"start": "react-scripts start",
"build": "react-scripts build",
"test": "react-scripts test",
"eject": "react-scripts eject"
},
"eslintConfig": {
"extends": [
"react-app",
"react-app/jest"
]
},
"browserslist": {
"production": [
">0.2%",
"not dead",
"not op_mini all"
],
"development": [
"last 1 chrome version",
"last 1 firefox version",
"last 1 safari version"
]
},
"devDependencies": {
"@types/prismjs": "^1.26.0",
"@types/styled-components": "^5.1.26"
}
}
Key Points:
1. Dependencies:
Various dependencies are listed under the "dependencies" section, including testing libraries (@testing-library/jest-dom, @testing-library/react, @testing-library/user-event), Firebase, PrismJS, React, React DOM, React Scripts, Styled Components, TypeScript, and Web Vitals.
2. Scripts:
Scripts for starting, building, testing, and ejecting the React app are defined in the "scripts" section ("start", "build", "test", "eject").
3. ESLint Configuration:
The ESLint configuration extends the default configurations provided by Create React App ("react-app", "react-app/jest").
4. Browserslist:
Browserslist configuration for different environments (production and development).
5. Dev Dependencies:
TypeScript typings for PrismJS ("@types/prismjs") and Styled Components ("@types/styled-components") are listed under "devDependencies".
The PROJECT-ROOT-FOLDER/package.json file provides the necessary information to manage the project's dependencies, scripts, and configurations.
/***************************** 2. PROJECT-ROOT-FOLDER/tsconfig.json **********************************************************************/
The tsconfig.json file for the /cotf project includes the TypeScript compiler options and project configuration.
Here's an overview of the key settings in the PROJECT-ROOT-FOLDER/tsconfig.json code file:
{
"compilerOptions": {
"target": "es5",
"lib": [
"dom",
"dom.iterable",
"esnext"
],
"allowJs": true,
"skipLibCheck": true,
"esModuleInterop": true,
"allowSyntheticDefaultImports": true,
"strict": true,
"forceConsistentCasingInFileNames": true,
"noFallthroughCasesInSwitch": true,
"module": "esnext",
"moduleResolution": "node",
"resolveJsonModule": true,
"isolatedModules": true,
"noEmit": true,
"jsx": "react-jsx"
},
"include": [
"src"
]
}
Key Points:
1. compilerOptions:
forceConsistentCasingInFileNames: Ensures consistent casing in file names.
2. include:
This tsconfig.json file defines the TypeScript compiler settings and project structure for your Quiz App.
/***************************** 3. PROJECT-ROOT-FOLDER/App.test.tsx **********************************************************************/
The PROJECT-ROOT-FOLDER/App.test.tsx file is a basic test for a React component using the testing library.
Let me explain the key points:
// Import necessary dependencies for testing
import React from "react";
import { render, screen } from "@testing-library/react";
// Import the component to be tested
import App from "./App";
// Define a test using the "test" function from the testing library
test("renders learn react link", () => {
// Render the component
render(<App />);
// Use the "screen" object to find an element with text "learn react"
const linkElement = screen.getByText(/learn react/i);
// Use an assertion to check if the element is in the document
expect(linkElement).toBeInTheDocument();
});
Explanation:
I1. mport Dependencies:
React: The React library.
render, screen: Functions from the testing library for rendering and interacting with the component.
2. Import Component:
import App from './App';: Import the React component (App) that you want to test.
3. Define Test:
test('renders learn react link', () => { ... });: Use the test function to define a test. The string parameter describes what the test is checking.
4. Render Component:
render(<App />);: Render the App component.
5. Find Element:
const linkElement = screen.getByText(/learn react/i);: Use the screen object to find an element containing the text "learn react" (case-insensitive) on the rendered component.
6. Assertion:
expect(linkElement).toBeInTheDocument();: Use the expect function to assert that the linkElement is present in the document. If it is not found, the test will fail.
This test checks if the "learn react" link is present in the rendered App component. You can customize this test based on the actual content and structure of your App component.
/***************************** 4. PROJECT-ROOT-FOLDER/App.tsx **********************************************************************/
The PROJECT-ROOT-FOLDER/App.tsx file is the main entry point for your React application (App.tsx).
Let's break down the key features:
// Import necessary dependencies from React and external libraries
import { useState } from "react";
import { ThemeProvider } from "styled-components";
// Import local components and context
import Main from "./components/Main";
import ToggleTheme from "./components/ui/ToggleTheme";
import QuizProvider from "./context/QuizContext";
// Import global styles and themes
import { GlobalStyles } from "./styles/Global";
import { themes } from "./styles/Theme";
// Define the main App component
function App() {
// State to manage the current theme, defaulting to 'light'
const [currentTheme, setCurrentTheme] = useState(() => {
const savedTheme = localStorage.getItem("theme");
return savedTheme || "light";
});
// Function to toggle the theme based on the checkbox state
const toggleTheme = (e: React.ChangeEvent<HTMLInputElement>) => {
const { checked } = e.target;
setCurrentTheme(checked ? "dark" : "light");
localStorage.setItem("theme", checked ? "dark" : "light");
};
// Determine the theme based on the currentTheme state
const theme = currentTheme === "light" ? themes.light : themes.dark;
// Render the main structure of the app
return (
<ThemeProvider theme={theme}>
{/* Apply global styles */}
<GlobalStyles />
{/* Provide the quiz context to the app */}
<QuizProvider>
{/* ToggleTheme component to switch between light and dark themes */}
<ToggleTheme
onChange={toggleTheme}
currentTheme={currentTheme}
checked={currentTheme === "dark"}
id="toggleTheme"
value="theme"
/>
{/* Main component representing the core of your application */}
<Main />
</QuizProvider>
</ThemeProvider>
);
}
// Export the App component as the default export
export default App;
Explanation:
1. State Management:
useState: Used to manage the state of the current theme (currentTheme).
2. Theme Handling:
ThemeProvider: Provided by styled-components to manage the theme for styled components.
themes: An object containing light and dark theme configurations.
3. Toggle Theme Functionality:
toggleTheme: Function to toggle between light and dark themes based on checkbox changes.
localStorage: Used to persist the selected theme in local storage.
4. Rendering:
<GlobalStyles />: Applies global styles using the createGlobalStyle from styled-components.
<QuizProvider>: Wraps the application with the QuizContext provider.
<ToggleTheme>: A component that allows users to switch between light and dark themes.
<Main />: The main component representing the core of your application.
This structure sets up the foundation for your React application, including theme handling, global styles, and the core functionality provided by the Main component within the context of a quiz.
/***************************** 5. PROJECT-ROOT-FOLDER/index.tsx **********************************************************************/
The PROJECT-ROOT-FOLDER/index.tsx file is the entry point for your React application (index.tsx).
Here's a breakdown of the key features:
// Import React and ReactDOM for rendering the app
import React from "react";
import ReactDOM from "react-dom/client";
// Import the main App component
import App from "./App";
// Import the function to report web vitals
import reportWebVitals from "./reportWebVitals";
// Create a React root using ReactDOM.createRoot
const root = ReactDOM.createRoot(
document.getElementById("root") as HTMLElement
);
// Render the App component inside the React root
root.render(
<React.StrictMode>
<App />
</React.StrictMode>
);
// If you want to measure performance in your app, pass a function
// to log results or send to an analytics endpoint
// Learn more: https://bit.ly/CRA-vitals
reportWebVitals();
Explanation:
1. React and ReactDOM:
React and ReactDOM are imported for building the React application.
2. App Component:
The App component is imported, representing the main structure of your application.
3. React Strict Mode:
The <React.StrictMode> component is used to enable additional development-related checks and warnings.
4. Root Element and Rendering:
ReactDOM.createRoot: Creates a root from a DOM element, in this case, the element with the ID 'root'.
root.render: Renders the App component within the React root.
5. Web Vitals:
reportWebVitals: A function that can be used to measure and report web vitals, providing insights into the performance of your application.
This file serves as the entry point to your React application, where the App component is rendered inside the root element. The use of StrictMode helps catch common mistakes and improve performance during development. The reportWebVitals function is available for measuring and reporting web vitals if desired.
/***************************** 6. PROJECT-ROOT-FOLDER/react-app-env.d.ts *******************************************************************/
The PROJECT-ROOT-FOLDER/react-app-env.d.ts is a TypeScript declaration file that references the types defined by react-scripts, which is a set of scripts and configurations used by Create React App (CRA).
Here's a brief explanation:
/// <reference types="react-scripts" />
Explanation:
1. Triple-Slash Directives:
/// is a triple-slash directive in TypeScript used for including files, typically declaration files or type definitions.
2. Reference to "react-scripts" Types:
<reference types="react-scripts" />: This directive tells TypeScript to include the type definitions provided by react-scripts. These types include the necessary declarations for the React scripts and configurations used in your Create React App project.
In a Create React App project, this file is automatically generated by CRA, and it helps TypeScript understand the types and declarations provided by the underlying tooling. It ensures that TypeScript can recognize and use the types defined by the dependencies and scripts configured in your React project.
/***************************** 7. PROJECT-ROOT-FOLDER/reportWebVitals.tsx ******************************************************************/
The PROJECT-ROOT-FOLDER/reportWebVitals.ts file is used to report web vitals metrics using the web-vitals library.
Here's a breakdown of the code:
import { ReportHandler } from "web-vitals";
const reportWebVitals = (onPerfEntry?: ReportHandler) => {
if (onPerfEntry && onPerfEntry instanceof Function) {
import("web-vitals").then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
getCLS(onPerfEntry);
getFID(onPerfEntry);
getFCP(onPerfEntry);
getLCP(onPerfEntry);
getTTFB(onPerfEntry);
});
}
};
export default reportWebVitals;
Explanation:
1. Import Statements:
Import the ReportHandler type from the 'web-vitals' library. This type is used to define a callback function that handles the reported metrics.
2. reportWebVitals Function:
Define a function named reportWebVitals that takes an optional onPerfEntry callback of type ReportHandler.
Check if the onPerfEntry callback is provided and is a function.
3. Dynamic Import of Metrics:
Dynamically import the 'web-vitals' module using the import function.
Once imported, it extracts individual metric functions (getCLS, getFID, getFCP, getLCP, getTTFB) from the module.
4. Call Metric Functions:
Call each metric function and pass the onPerfEntry callback to report the metric data.
5. Export:
Export the reportWebVitals function.
This file is typically used in a Create React App (CRA) project to automatically report web vitals metrics during development. The reported metrics help developers monitor and improve the performance of their web applications.
/***************************** 8. PROJECT-ROOT-FOLDER/setupTests.ts **********************************************************************/
The PROJECT-ROOT-FOLDER/setupTests.ts file is a setup file for Jest tests in a React project. This file is typically used to configure Jest before running the tests. In this specific case, it includes the @testing-library/jest-dom library, which provides custom Jest matchers for asserting on DOM nodes.
Here's the breakdown of the code:
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
// Import the '@testing-library/jest-dom' library
import '@testing-library/jest-dom';
Explanation:
1. Comments:
The comments provide information about the purpose of the @testing-library/jest-dom library.
It mentions that this library adds custom Jest matchers for asserting on DOM nodes.
2. Import Statement:
Import the @testing-library/jest-dom library.
This library extends Jest's capabilities for testing React components by providing additional matchers for DOM-related assertions.
3. Learn More Link:
A comment includes a link (https://github.com/testing-library/jest-dom) that directs users to the GitHub repository for more information about the @testing-library/jest-dom library.
This setup file ensures that the custom Jest matchers provided by @testing-library/jest-dom are available for use in your Jest tests. These matchers are commonly used with the jest-dom assertions to make it easier to test React components and their interactions with the DOM.
/***************************** 9. PROJECT-ROOT-FOLDER/src/components/Main/index.tsx ******************************************/
The PROJECT-ROOT-FOLDER/src/components/Main/index.tsx component manages the rendering of different screens based on the currentScreen state from the QuizContext. The useEffect is used to simulate a delay (1 second) before transitioning to the QuizTopicsScreen. The screenComponents object maps each screen type to its corresponding component.
/***************************** 10. PROJECT-ROOT-FOLDER/src/components/QuestionScreen/Answer/index.tsx ****************************/
The PROJECT-ROOT-FOLDER/src/components/QuestionScreen/Answer/index.tsx component appears to be a styled component that represents an answer choice in a quiz. It is part of the QuestionScreen and is used to display multiple answer choices.
Here's a breakdown of the code:
AnswerStyle: This styled component defines the style for each answer choice. It sets the font size, color, border, background color, border radius, margin, and cursor properties. It also handles transitions when an answer is highlighted. The styles are responsive, adjusting based on the screen size.
AnswerLabel: This styled component defines the style for the label that wraps each answer choice. It sets padding, display, and cursor properties.
ChoiceLabel: This styled component defines the style for the label that displays the alphabetical character (A, B, C, etc.) before each answer choice.
Answer component: This functional component receives props such as onChange, index, choice, type, and selectedAnswer. It renders an answer choice with a label showing the alphabetical character, an input element (checkbox or radio button), and the actual choice text. The Answer component is conditionally styled based on whether the answer is selected.
/***************************** 11. PROJECT-ROOT-FOLDER/src/components/QuestionScreen/Question/index.tsx ****************/
The PROJECT-ROOT-FOLDER/src/components/QuestionScreen/Question/index.tsx component seems to be responsible for rendering a quiz question, including the question text, image (if present), and the list of answer choices.
Here's a breakdown of the code:
QuestionContainer: A styled component for the overall container of the question. It sets margin and max-width properties, making it responsive to different screen sizes.
AnswersContainer: A styled component for the container of answer choices. It sets a max-width property, also responsive to different screen sizes.
QuestionStyle: A styled component for the question text. It sets font size, font weight, margin, color, and line height properties. The font size is responsive based on the viewport width.
Question component: This functional component receives props such as question, code, image, type, choices, selectedAnswer, and handleAnswerSelection. It renders the question text using QuestionStyle and conditionally renders an image (QuizImage). It then maps through the answer choices (choices array) and renders each using the Answer component.
The handleAnswerSelection function is passed down to the Answer component to handle the selection of answers.
/***************************** 12. PROJECT-ROOT-FOLDER/src/components/QuestionScreen/QuizHeader/index.tsx ************/
The PROJECT-ROOT-FOLDER/src/components/QuestionScreen/QuizHeader/index.tsx component seems to be responsible for displaying information related to the quiz header, including the active question number, total questions, a timer, and an indicator for skipped questions.
Here's a breakdown of the code:
ActiveQuestionNo: A styled component for displaying the active question number. It sets properties such as font size, font weight, and color.
SkippedQuestionStyle: A styled component for indicating a skipped question. It sets properties such as font size, font weight, color, background color, border radius, margin, padding, and text-align.
TotalQuestionNo: A styled component for displaying the total number of questions. It sets properties similar to ActiveQuestionNo.
QuizHeader component: This functional component receives props such as activeQuestion, totalQuestions, timer, and skipped. It renders a Flex container with space between items and a small gap. Inside the container, it displays the active question number, total questions, and a Counter component for the timer. If a question is skipped, it also displays the SkippedQuestionStyle component.
/***************************** 13. PROJECT-ROOT-FOLDER/src/components/QuestionScreen/QuizHeader/Counter/index.tsx *********/
The Counter component appears to be a simple component responsible for displaying a timer icon along with the time.
Here's a breakdown of the code:
TimerStyle: A styled component for the timer text. It sets properties such as min-width, font size (responsive based on viewport width), font weight, margin-left, and color.
Counter component: This functional component receives the time prop and renders a Flex container that centers its content. Inside the container, it renders the TimerIcon and the TimerStyle component, which displays the time.
/***************************** 14. PROJECT-ROOT-FOLDER/src/components/QuizDetailsScreen/index.tsx ******************************/
The PROJECT-ROOT-FOLDER/src/components/QuizDetailsScreen/index.tsx component appears to be the main component responsible for rendering quiz questions, handling user interactions, and managing the flow of the quiz.
Here's a breakdown of the code:
QuizContainer: A styled component that represents the main container for the quiz. It includes styling for width, background, border-radius, padding, and margins.
LogoContainer: A styled component that contains the app logo.
ButtonWrapper: A styled component for positioning buttons at the bottom right of the quiz container.
QuestionScreen component: This functional component includes state variables such as activeQuestion, selectedAnswer, showTimerModal, and showResultModal. It also utilizes various hooks and functions from the context (useQuiz and useTimer). The component renders the following:
The app logo (AppLogo component) within the LogoContainer.
The QuizContainer that includes the QuizHeader component, Question component, and a set of buttons (ButtonWrapper).
A modal (ModalWrapper) that is displayed when the quiz timer reaches zero or when the user finishes the quiz. The modal includes a title, subtitle, an icon, and a button to show the quiz results.
The QuizHeader component, responsible for displaying information about the current question, total questions, and timer.
The Question component, which renders the current quiz question, including the question text, code snippet (if any), image (if any), and answer choices.
Buttons for skipping the current question and navigating to the next question or finishing the quiz.
The useTimer hook to manage the quiz timer and handle related conditions.
The component appears well-structured, and it manages the quiz flow efficiently.
/***************************** 15. PROJECT-ROOT-FOLDER/src/components/QuizTopicsScreen/index.tsx ******************************/
The PROJECT-ROOT-FOLDER/src/components/QuizTopicsScreen/index.tsx component is responsible for displaying a list of quiz topics that users can choose from before starting the quiz.
Here's an overview of the code:
Heading: A styled component for the main heading of the screen.
DetailText: A styled component for additional details or instructions displayed on the screen.
SelectButtonContainer: A styled component for a container that holds the selectable quiz topics. It uses flexbox to align the buttons and adjusts the layout based on the device's screen size.
SelectButton: A styled component for each individual quiz topic button. It includes conditional styling based on whether the button is active, disabled, or clickable.
SelectButtonText: A styled component for the text inside each quiz topic button.
QuizTopicsScreen component: This functional component includes the following elements:
The app logo (AppLogo component) within the LogoContainer.
The main heading (Heading) with a highlighted text.
Detail text (DetailText) providing additional information or instructions.
SelectButtonContainer containing a set of SelectButton components, each representing a quiz topic. The buttons are created based on the data provided in the quizTopics array.
A "CONTINUE" button (Button component) that triggers the transition to the next screen (QuizDetailsScreen) when clicked.
Event handlers (goToQuizDetailsScreen and the onClick function within each SelectButton) to handle user interactions.
Access to the quiz context using the useQuiz hook to get and update the selected quiz topic, current screen, etc.
Overall, the QuizTopicsScreen component provides an intuitive interface for users to select a quiz topic and proceed to the quiz details screen.
/***************************** 16. PROJECT-ROOT-FOLDER/src/components/ResultScreen/index.tsx ******************************/
The ResultScreen component is responsible for displaying the results of the quiz, including an overview of the user's performance and detailed information for each question.
Here's a breakdown of the code:
ResultScreenContainer: A styled component for the main container of the result screen. It defines the maximum width, margin, and padding.
InnerContainer: A styled component for an inner container within the result screen. It defines the background color, border radius, margin, and padding.
QuestionContainer: A styled component for the container of each question's details. It uses a flex layout with space-between for responsive design.
QuestionNumber: A styled component for displaying the question number.
QuestionStyle: A styled component for displaying the question text.
Answer: A styled component for displaying each answer option. It includes different styles for correct and wrong answers.
Score: A styled component for displaying the score for each question. It changes color based on whether the answer is correct or wrong.
ResultScreen component: This functional component includes the following elements:
It uses the ResultOverview component to display an overview of the user's performance, including the number of questions attempted, the score secured, time spent, and the overall status (Passed/Failed).
It then maps over the result array to display detailed information for each question. For each question, it displays the question number, question text, image (if any), answer options, and the user's selected answers with correct and wrong answer indications.
It uses the RightAnswer component to display the correct answers for questions that were answered incorrectly.
The user's score for each question is displayed with a color-coded indicator (green for correct, red for wrong).
Finally, a "Retry" button is provided to allow the user to retry the quiz.
Overall, the ResultScreen component provides a comprehensive view of the quiz results, allowing the user to review their performance on each question.
/***************************** 17. PROJECT-ROOT-FOLDER/src/components/ResultScreen/ResultOverview/index.tsx ************/
The PROJECT-ROOT-FOLDER/src/components/ResultScreen/ResultOverview/index.tsx component is responsible for displaying an overview of the quiz results, including the number of questions attempted, the obtained score, time spent, and the overall status (Passed or Failed).
Here's a breakdown of the code:
ResultOverviewStyle: A styled component for the overall styling of the result overview. It includes text alignment and margin properties.
ResultOverview component: This functional component takes a result prop, which is an array of Result objects. It includes the following elements:
Access to the quiz context using the useQuiz hook to get information such as quizDetails and endTime.
Calculation of the total number of questions attempted (totalQuestionAttempted) by counting the length of the result array.
Calculation of the obtained score (obtainedScore) by filtering the result array to include only matching and numeric scores, and then using reduce to sum the scores.
Calculation of the status (calculateStatus) based on whether the obtained score is 60% or more of the total score.
Display of the total questions attempted, obtained score, time spent, and status using p elements. The relevant information is highlighted using the HighlightedText styled component.
Overall, the ResultOverview component provides a concise summary of the quiz results.
/***************************** 18. PROJECT-ROOT-FOLDER/src/components/ResultScreen/RightAnswer/index.tsx ************/
The PROJECT-ROOT-FOLDER/src/components/ResultScreen/RightAnswer/index.tsx component is responsible for displaying the correct answers to a question in the quiz result.
Here's a breakdown of the code:
RightAnswerContainer: A styled component for the container of the right answer text. It defines the font size, weight, color, margin, and line height.
RightAnswer component: This functional component takes correctAnswers and choices as props. It includes the following elements:
The component renders a paragraph (p) element that starts with the text "Right Answer(s): ".
It then maps over the correctAnswers array to display each correct answer. For each correct answer, it calculates the label (A, B, C, etc.) based on the index of the answer in the choices array.
The label and answer are displayed using the HighlightedText styled component.
If there are multiple correct answers, a comma is added between them for better readability.
Overall, the RightAnswer component provides a clear indication of the correct answers for a particular question in the quiz result.
/***************************** 19. PROJECT-ROOT-FOLDER/src/components/SplashScreen/index.tsx ******************************/
The PROJECT-ROOT-FOLDER/src/components/SplashScreen/index.tsx component is designed to display a loading or splash screen with an animated logo.
Here's a breakdown of the code:
LogoAnimation: A styled component for the animated logo. It uses CSS transitions to smoothly change the width of the SVG logo based on the logoSize prop.
SplashScreen component:
It manages the state of logoSize using the useState hook to dynamically adjust the size of the logo based on the window width.
The useEffect hook is used to add an event listener for window resize events. It sets up an initial logo size and updates the logo size when the window is resized.
The handleResize function is responsible for updating the logoSize based on the window width.
The AppLogo component is rendered inside the LogoAnimation component, creating the animated logo.
The SplashScreen component is centered on the page using the PageCenter styled component.
Overall, the SplashScreen component provides a visually appealing loading screen with a dynamic and animated logo that adjusts its size based on the window width.
/***************************** 20. PROJECT-ROOT-FOLDER/src/components/ui/Button/index.tsx ************/
The PROJECT-ROOT-FOLDER/src/components/ui/Button/index.tsx component is a reusable UI component that allows you to create buttons with various configurations. Here's a breakdown of the code:
ButtonTypes: An interface defining the props for the Button component.
The available props include:
text: The text content of the button.
onClick: The click event handler for the button.
icon: An optional ReactNode for an icon to be displayed within the button.
iconPosition: The position of the icon (either 'left' or 'right').
outline: A boolean indicating whether the button should have an outline style.
bold: A boolean indicating whether the text should be bold.
big: A boolean indicating whether the button should have a larger size.
disabled: A boolean indicating whether the button should be disabled.
Button: The functional component that renders the button based on the provided props. It uses the ButtonStyle styled component and handles the rendering of the text and icons based on the specified positions.
The ButtonStyle, IconLeft, and IconRight seem to be styled components used to define the styles for the button and its icons. However, the actual styles are not provided in the code snippet.
/***************************** 21. PROJECT-ROOT-FOLDER/src/components/ui/Button/styled.tsx ************/
The PROJECT-ROOT-FOLDER/src/components/ui/Button/styled.tsx file defines styled components for a Button in a React application using the styled-components library.
Let's break down the key features:
ButtonStyle Component:
This styled component is created using the styled.button syntax from styled-components.
It uses the .attrs method to dynamically set attributes based on the props passed to the component (outline, bold, big).
The component accepts props for customization such as outline, bold, and big.
CSS styles are defined within the template literal using the ${({ prop }) => ...} syntax for dynamic values.
Responsive styling is applied using the @media query from the device in BreakPoints.ts.
IconLeft and IconRight Components:
These styled components define styles for the left and right icons inside the button.
They use the styled.span syntax and apply specific margin and fill color to the SVG path.
Here's the code:
import styled from "styled-components";
import { device } from "../../../styles/BreakPoints";
interface ButtonType {
outline?: boolean;
bold?: boolean;
big?: boolean;
}
export const ButtonStyle = styled.button.attrs(
({ outline, bold, big }: ButtonType) => ({
outline,
bold,
big,
})
)`
width: 195px;
min-height: 50px;
color: ${({ theme, outline }) =>
outline ? theme.colors.outlineButtonText : theme.colors.buttonText};
background: ${({ theme, outline }) =>
outline ? theme.colors.cardBackground : theme.colors.buttonBackground};
font-size: clamp(16px, 5vw, 24px);
border: 1px solid
${({ theme, outline }) => (!outline ? "none" : theme.colors.themeColor)};
font-weight: ${({ bold }) => (bold ? "700" : "400")};
border-radius: 9px;
display: flex;
justify-content: center;
align-items: center;
@media ${device.md} {
width: ${({ big }) => (big ? "180px" : "150px")};
min-height: 40px;
tap-highlight-color: transparent;
-webkit-tap-highlight-color: transparent;
}
&:active {
transform: scale(0.98);
box-shadow: ${({ theme }) => theme.shadows.activeButton};
transition: 0.2s all;
}
&:disabled {
background: ${({ theme }) => theme.colors.disabledButton};
color: ${({ theme }) => theme.colors.darkGray};
cursor: not-allowed;
transform: unset;
box-shadow: unset;
}
`;
export const IconLeft = styled.span`
margin-right: 10px;
display: flex;
svg {
path {
fill: ${({ theme }) => theme.colors.buttonText};
}
}
`;
export const IconRight = styled.span`
margin-left: 20px;
display: flex;
svg {
path {
fill: ${({ theme }) => theme.colors.buttonText};
}
};
This code provides a flexible and reusable button component with styling options for different scenarios. The IconLeft and IconRight components allow for the inclusion of icons with specific styling.
/***************************** 22. PROJECT-ROOT-FOLDER/src/components/ui/Input/index.tsx ************/
The PROJECT-ROOT-FOLDER/src/components/ui/Input/index.tsx component is a simple styled input field that accepts certain props to customize its behavior.
Here's a breakdown of the code:
// src/components/ui/Input/index.tsx
import React from "react";
import styled from "styled-components";
// Styled component for the input field
const StyledInput = styled.input`
width: 100%;
padding: 10px;
margin-bottom: 10px;
border: 1px solid #ccc;
border-radius: 4px;
box-sizing: border-box;
font-size: 16px;
`;
// Props for the Input component
interface InputProps {
type?: string;
value: string | number;
onChange: (event: React.ChangeEvent<HTMLInputElement>) => void;
min?: number;
max?: number;
}
// Functional component representing the input field
const Input: React.FC<InputProps> = ({
type = "text",
value,
onChange,
min,
max,
}) => (
<StyledInput
type={type}
value={value}
onChange={onChange}
min={min}
max={max}
/>
);
export default Input;
Explanation:
StyledInput: This is a styled component using styled-components to define the styles for the input element. It sets the width, padding, margin, border, border radius, box sizing, and font size.
InputProps: This is an interface defining the props that the Input component can receive. It includes type, value, onChange, min, and max.
Input: This is the functional component that renders the input element with the styles defined in StyledInput. It takes in the props, and the default type is set to 'text'. The value and onChange props are used to control the input value, and min and max are optional for number inputs.
Overall, it's a reusable input component that you can use across your application.
/***************************** 23. PROJECT-ROOT-FOLDER/src/components/ui/ModalWrapper/index.tsx ************/
The PROJECT-ROOT-FOLDER/src/components/ui/ModalWrapper/index.tsx component is a reusable modal component that displays a title, subtitle, an icon, and a button. It is styled using styled-components.
Here's a breakdown of the code:
// src/components/ui/ModalWrapper/index.tsx
import { FC } from "react";
import styled from "styled-components";
import Button from "../Button";
// Container for the modal overlay
const ModalContainer = styled.div`
position: fixed;
top: 0;
left: 0;
width: 100%;
height: 100%;
background-color: rgba(0, 0, 0, 0.5);
display: flex;
justify-content: center;
align-items: center;
padding: 15px;
`;
// Styled content of the modal
const ModalContent = styled.div`
width: 600px;
padding: 50px 25px;
background: ${({ theme }) => theme.colors.cardBackground};
border-radius: 10px;
display: flex;
align-items: center;
flex-direction: column;
`;
// Title of the modal
const ModalTitle = styled.h6`
font-size: clamp(24px, 4vw, 32px);
font-weight: 700;
color: ${({ theme }) => theme.colors.themeColor};
margin-top: 26px;
margin-bottom: 20px;
`;
// Subtitle of the modal
const ModalSubtitle = styled.p`
font-size: clamp(18px, 4vw, 24px);
font-weight: 500;
text-align: center;
line-height: 1.3;
color: ${({ theme }) => theme.colors.primaryText};
margin-bottom: clamp(18px, calc(18px + 28 * ((100vw - 600px) / 1320)), 48px);
`;
// Props for the ModalWrapper component
interface ModalWrapperProps {
title: string;
subtitle: string;
icon: JSX.Element;
buttonTitle: string;
onClick: () => void;
}
// ModalWrapper component
const ModalWrapper: FC<ModalWrapperProps> = ({
title,
subtitle,
icon,
buttonTitle,
onClick,
}) => {
return (
<ModalContainer>
<ModalContent>
{icon}
<ModalTitle>{title}</ModalTitle>
<ModalSubtitle>{subtitle}</ModalSubtitle>
<Button text={buttonTitle} onClick={onClick} bold big />
</ModalContent>
</ModalContainer>
);
};
export default ModalWrapper;
Explanation:
ModalContainer: This styled component represents the overlay of the modal. It covers the entire screen with a semi-transparent background.
ModalContent: This styled component represents the content of the modal. It has a fixed width, padding, background color, and border-radius.
ModalTitle and ModalSubtitle: These styled components define the styles for the title and subtitle of the modal.
ModalWrapperProps: This is an interface defining the props that the ModalWrapper component can receive. It includes title, subtitle, icon, buttonTitle, and onClick.
ModalWrapper: This is the functional component that renders the modal using the styled components. It takes in the props and renders the title, subtitle, icon, and a button. The onClick prop is called when the button is clicked.
This ModalWrapper component can be used to display modal dialogs with different titles, subtitles, icons, and buttons throughout your application.
/***************************** 24. PROJECT-ROOT-FOLDER/src/components/ui/QuizImage/index.tsx ************/
The PROJECT-ROOT-FOLDER/src/components/ui/QuizImage/index.tsx component is a simple functional component that takes an image prop and renders an image with some styling.
Here's the code breakdown:
// src/components/ui/QuizImage/index.tsx
import { FC } from "react";
import styled from "styled-components";
// Props for the QuizImage component
interface QuizImageProps {
image: string;
}
// Styled component for the image
const ImageStyle = styled.img`
border-radius: 10px;
height: 400px; // Set a fixed height for the image
max-width: 100%; // Ensure the image does not exceed its container's width
box-shadow: 6px 6px 2px ${({ theme }) =>
theme.colors.themeColor}; // Add a box shadow
margin-bottom: 20px; // Add a margin at the bottom
`;
// QuizImage component
const QuizImage: FC<QuizImageProps> = ({ image }) => (
<ImageStyle src={image} alt="picture quiz" />
);
export default QuizImage;
Explanation:
QuizImageProps: This is an interface defining the props that the QuizImage component can receive. It includes a single property, image, which is a string representing the URL of the image.
ImageStyle: This styled component represents the styling for the image. It has a border-radius, a fixed height of 400px, a maximum width of 100%, a box shadow, and a margin at the bottom.
QuizImage: This is the functional component that renders an img element. It takes the image prop and sets it as the src attribute of the image. The alt attribute is set to "picture quiz."
This component can be used to display images in a quiz context.
/***************************** 25. PROJECT-ROOT-FOLDER/src/components/ui/ToggleTheme/index.tsx ************/
The PROJECT-ROOT-FOLDER/src/components/ui/ToggleTheme/index.tsx component is a toggle switch that allows users to switch between light and dark themes.
Here's the breakdown of the code:
// src/components/ui/ToggleTheme/index.tsx
import React, { FC } from "react";
import styled, { keyframes } from "styled-components";
import { Moon, Sun } from "../../../config/icons";
// Styled label for the toggle switch
const ToggleLabel = styled.label`
font-size: 16px;
font-weight: 700;
color: ${({ theme }) => theme.colors.themeText};
display: flex;
align-items: center;
position: absolute;
top: 12px;
right: 25px;
`;
// Keyframes for the slide animations
const SlideOn = keyframes`
0% {
transform: translateX(0) scale(1);
}
50% {
transform: translateX(15px) scale(1.1);
}
100% {
transform: translateX(23px) scale(1);
}
`;
const SlideOff = keyframes`
0% {
transform: translateX(23px) scale(1);
}
50% {
transform: translateX(15px) scale(1.1);
}
100% {
transform: translateX(0px) scale(1);
}
`;
// Styled input for the toggle switch
const ToggleInput = styled.input`
visibility: hidden;
border: 1px solid red;
margin: 0;
&:checked + span {
background-color: ${({ theme }) => theme.colors.dark};
svg {
animation: ${SlideOn} 0.2s linear forwards;
}
}
&:checked + span::after {
background-color: ${({ theme }) => theme.colors.white};
animation: ${SlideOn} 0.2s linear forwards;
}
`;
// Styled span representing the ball in the toggle switch
const Ball = styled.span`
width: 52px;
height: 26px;
background-color: ${({ theme }) => theme.colors.white};
display: inline-block;
cursor: pointer;
border-radius: 50px;
position: relative;
svg {
position: absolute;
top: 5px;
left: 7px;
z-index: 1;
animation: ${SlideOff} 0.2s linear forwards;
}
&::after {
content: '';
width: 21px;
height: 21px;
background-color: ${({ theme }) => theme.colors.dark};
border-radius: 50%;
display: inline-block;
position: absolute;
top: 3px;
left: 5px;
align-items: center;
justify-content: center;
animation: ${SlideOff} 0.2s linear forwards;
}
`;
// Props for the ToggleTheme component
interface ToggleThemeProps {
onChange: (event: React.ChangeEvent<HTMLInputElement>) => void;
id: string;
value: string;
checked: boolean;
currentTheme: string;
}
// ToggleTheme component
const ToggleTheme: FC<ToggleThemeProps> = ({
onChange,
id,
value,
checked,
currentTheme,
}) => {
return (
<ToggleLabel htmlFor={id}>
Mode:
<ToggleInput
type="checkbox"
id={id}
onChange={onChange}
value={value}
checked={checked}
/>
<Ball>{currentTheme === "light" ? <Sun /> : <Moon />}</Ball>
</ToggleLabel>
);
};
export default ToggleTheme;
Explanation:
ToggleLabel: A styled label component that includes the text "Mode:" and the toggle switch.
SlideOn and SlideOff: Keyframe animations for sliding the switch ball on and off.
ToggleInput: A styled input element that is visually hidden. When checked, it changes the background color and triggers animations.
Ball: A styled span representing the ball in the toggle switch. It includes animations for the sliding effect and displays either the Sun or Moon icon based on the current theme.
ToggleThemeProps: An interface defining the props that the ToggleTheme component can receive, including onChange, id, value, checked, and currentTheme.
ToggleTheme: The functional component that renders the toggle switch. It uses the styled components defined above and displays the Sun or Moon icon based on the current theme.
This component can be used to implement a theme toggle switch in your application.
/***************************** 26. PROJECT-ROOT-FOLDER/src/components/UserInput/QuestionInput.tsx ******************************/
The PROJECT-ROOT-FOLDER/src/components/UserInput/QuestionInput.tsx component is designed to allow the user to input the number of questions they want for a quiz and start the quiz.
Here's the breakdown of the code:
/ src/cemnnoopst / UserInput / QuestionInput.tsx;
import React, { useState } from "react";
import styled from "styled-components";
import Button from "../ui/Button";
import Input from "../ui/Input";
// Styled container for input and button
const InputContainer = styled.div`
margin-top: 15px;
`;
// QuestionInput component
const QuestionInput: React.FC<{
totalQuestions: number;
setUserSelectedQuestions: React.Dispatch<React.SetStateAction<number>>;
startQuiz: () => void;
}> = ({ totalQuestions, setUserSelectedQuestions, startQuiz }) => {
// State to manage the input value
const [inputValue, setInputValue] = useState(1);
// Event handler for input change
const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
const value = parseInt(e.target.value, 10);
setInputValue(value);
};
// Event handler for starting the quiz
const handleStartQuiz = () => {
// Ensure that the selected questions are between 1 and the total number of questions
const selectedQuestions = Math.min(Math.max(1, inputValue), totalQuestions);
setUserSelectedQuestions(selectedQuestions);
startQuiz();
};
return (
<InputContainer>
{/* Input component for the number of questions */}
<Input
type="number"
value={inputValue}
onChange={handleInputChange}
min={1}
max={totalQuestions}
/>
{/* Button component to start the quiz */}
<Button text="Start Quiz" onClick={handleStartQuiz} />
</InputContainer>
);
};
export default QuestionInput;
Explanation:
InputContainer: A styled component that serves as a container for the input and button.
QuestionInput: The functional component that includes an input field (Input) for the user to enter the number of questions and a button (Button) to start the quiz. It manages the state of the input value and ensures that the selected number of questions is within a valid range.
totalQuestions: The total number of questions available for the quiz.
setUserSelectedQuestions: A function to set the user-selected number of questions in the parent component's state.
startQuiz: A function to initiate the quiz when the user clicks the "Start Quiz" button.
This component can be used to collect user input for the number of questions they want and initiate the quiz accordingly.
/***************************** 27. PROJECT-ROOT-FOLDER/src/config/icons.ts ******************************/
The PROJECT-ROOT-FOLDER/src/config/icons.ts file in the /src/config directory serves as an export file for various SVG icons. Each icon is imported from its respective SVG file in the /src/assets/icons directory. The file exports these icons for use in other parts of your application.
Here's a summary of the code:
// src/config/icons.ts
// Import SVG icons
import { ReactComponent as AppLogo } from '../assets/icons/app-logo.svg'
import { ReactComponent as CheckIcon } from '../assets/icons/check.svg'
import { ReactComponent as Next } from '../assets/icons/next.svg'
import { ReactComponent as Previous } from '../assets/icons/previous.svg'
import { ReactComponent as Refresh } from '../assets/icons/refresh.svg'
import { ReactComponent as TimerIcon } from '../assets/icons/timer.svg'
import { ReactComponent as StartIcon } from '../assets/icons/start.svg'
import { ReactComponent as Sun } from '../assets/icons/sun.svg'
import { ReactComponent as Moon } from '../assets/icons/moon.svg'
// Export the icons
export { AppLogo, CheckIcon, Next, Previous, Refresh, TimerIcon, StartIcon, Sun, Moon }
Explanation:
The import statements bring in each SVG icon as a React component.
The export statement at the end of the file exports all the icons, making them available for use in other parts of your application.
Icons include an application logo (AppLogo), checkmark (CheckIcon), navigation arrows (Next and Previous), refresh icon (Refresh), timer icon (TimerIcon), start icon (StartIcon), and theme switch icons (Sun and Moon).
This modular structure allows you to manage and reuse icons throughout your application easily.
/***************************** 28. PROJECT-ROOT-FOLDER/src/context/QuizContext.tsx ******************************/
The PROJECT-ROOT-FOLDER/src/context/QuizContext.tsx file in the /src/context directory defines a React context named QuizContext and provides a QuizProvider component that wraps the application to manage quiz-related state.
Here's an overview of the code:
// src/context/QuizContext.tsx
import {
ReactNode,
createContext,
useContext,
useEffect,
useState,
} from "react";
import { quiz } from "../data/QuizQuestions";
import { QuizContextTypes, Result, ScreenTypes } from "../types";
// Initial state for the context
const initialState: QuizContextTypes = {
currentScreen: ScreenTypes.SplashScreen,
setCurrentScreen: () => {},
quizTopic: "Coheed and Cambria",
selectQuizTopic: () => {},
questions: [],
setQuestions: () => {},
result: [],
setResult: () => {},
timer: 15,
setTimer: () => {},
endTime: 0,
setEndTime: () => {},
quizDetails: {
totalQuestions: 0,
totalScore: 0,
totalTime: 0,
selectedQuizTopic: "Coheed and Cambria",
},
};
// Create the context
export const QuizContext = createContext<QuizContextTypes>(initialState);
// Hook to access the context
export function useQuiz() {
return useContext(QuizContext);
}
// Props for the QuizProvider component
type QuizProviderProps = {
children: ReactNode;
};
// The QuizProvider component
const QuizProvider = ({ children }: QuizProviderProps) => {
const [timer, setTimer] = useState<number>(initialState.timer);
const [endTime, setEndTime] = useState<number>(initialState.endTime);
const [quizTopic, setQuizTopic] = useState<string>(initialState.quizTopic);
const [result, setResult] = useState<Result[]>(initialState.result);
const [currentScreen, setCurrentScreen] = useState<ScreenTypes>(
initialState.currentScreen
);
const [questions, setQuestions] = useState(
quiz[initialState.quizTopic].questions
);
const {
questions: quizQuestions,
totalQuestions,
totalTime,
totalScore,
} = quiz[quizTopic];
const selectQuizTopic = (topic: string) => {
setQuizTopic(topic);
};
useEffect(() => {
setTimer(totalTime);
setQuestions(quizQuestions);
}, [quizTopic]);
const quizDetails = {
totalQuestions,
totalScore,
totalTime,
selectedQuizTopic: quizTopic,
};
const quizContextValue: QuizContextTypes = {
currentScreen,
setCurrentScreen,
quizTopic,
selectQuizTopic,
questions,
setQuestions,
result,
setResult,
quizDetails,
timer,
setTimer,
endTime,
setEndTime,
};
// Provide the context value to the children components
return (
<QuizContext.Provider value={quizContextValue}>
{children}
</QuizContext.Provider>
);
};
export default QuizProvider;
Explanation:
The QuizContext is created using createContext, and the useQuiz hook allows components to access the context.
The QuizProvider component serves as a provider for the quiz-related state. It initializes state variables such as timer, endTime, quizTopic, result, and currentScreen.
The selectQuizTopic function allows changing the current quiz topic.
The useEffect hook is used to update the timer and questions when the quiz topic changes.
The quizDetails object contains details about the current quiz.
The quizContextValue object contains all the state and functions provided by the context.
The QuizProvider component wraps its children with QuizContext.Provider to provide the context value.
This context is designed to manage the state related to the quiz throughout the application. Components can use the useQuiz hook to access and modify this state.
/***************************** 29. PROJECT-ROOT-FOLDER/src/data/quizTopics.tsx ******************************/
The PROJECT-ROOT-FOLDER/src/data/quizTopics.tsx file in the /src/data directory defines an array of quiz topics. Each quiz topic is represented as an object with a title, an icon, and an optional disabled property.
Here's the code:
// src/data/quizTopics.tsx
import { ReactNode } from "react";
import { ReactComponent as JavaScript } from "../assets/icons/javascript.svg";
import { ReactComponent as Python } from "../assets/icons/python.svg";
import { ReactComponent as ReactIcon } from "../assets/icons/react.svg";
import { ReactComponent as BulbIcon } from "../assets/icons/bulb.svg";
import { ReactComponent as Coheed } from "../assets/icons/app-logo.svg";
type QuizTopic = {
title: string;
icon: ReactNode;
disabled?: boolean;
};
// Array of quiz topics
export const quizTopics: QuizTopic[] = [
{
title: "Coheed and Cambria",
icon: <Coheed />,
},
{
title: "AMORY WARS",
icon: <Coheed />,
},
{
title: "Side Projects",
icon: <Coheed />,
},
{
title: "S.S. Neverender",
icon: <Coheed />,
},
];
Explanation:
The QuizTopic type defines the structure of each quiz topic object, which includes a title (string), an icon (ReactNode), and an optional disabled property (boolean).
The quizTopics array contains objects representing different quiz topics. Each object has a title (e.g., 'Coheed and Cambria') and an icon (e.g., <Coheed />).
The icon property is assigned React components representing icons for each quiz topic. For example, the <Coheed /> component is used as the icon for each topic.
The disabled property is optional and can be used to indicate whether a quiz topic is disabled.
This file serves as a data source for the available quiz topics in your application. Components can import and use quizTopics to dynamically generate content based on these topics.
/***************************** 30. PROJECT-ROOT-FOLDER/src/data/QuizQuestions/amory.ts, etc ************/
The PROJECT-ROOT-FOLDER/src/data/QuizQuestions files are a template for structuring quiz questions in different files based on quiz topics. This is a good organization, and it follows a clear pattern. Each file (amory.ts, coheed.ts, neverender.ts, sideProjects.ts) contains a set of questions related to a specific quiz topic.
Here is a brief explanation of the structure:
// Example format for quiz questions in amory.ts, coheed.ts, neverender.ts, sideProjects.ts
// Import the Topic type from a shared module (possibly an index.ts file)
import { Topic } from ".";
export const topic: Topic = {
topic: "QUIZ TOPIC GOES HERE",
level: "Beginner",
totalQuestions: TOTAL NUMBER OF QUESTIONS IN THE SELECTED QUIZ GOES HERE,
totalScore: THE SCORE THAT IS POSSIBLE IF ALL QUESTIONS ARE ANSWERED CORRECTLY GOES HERE,
totalTime: THE TIME THAT THE USER HAS TO FINISH THE QUIZ GOES HERE. TIME IS IN SECONDS FORMAT,
questions: [
{
question:
"QUESTION TO BE ASKED GOES HERE?",
choices: [
"ANSWER CHOICE 1",
"ANSWER CHOICE 2",
"ANSWER CHOICE 3",
"ANSWER CHOICE 4",
],
type: "MCQs",
correctAnswers: ["ANSWER GOES HERE"],
score: 5,
},
{
question: 'QUESTION TO BE ASKED GOES HERE?.',
choices: ['True', 'False'],
type: 'boolean',
correctAnswers: ['ANSWER GOES HERE'],
score: 5,
},
{
question:
'QUESTION TO BE ASKED GOES HERE? (Select all that apply)',
choices: ['ANSWER CHOICE 1', 'ANSWER CHOICE 2', 'ANSWER CHOICE 3', 'ANSWER CHOICE 4'],
type: 'MAQs',
correctAnswers: ['CORRECT ANSWER 1 GOES HERE', 'CORRECT ANSWER 2 GOES HERE', 'CORRECT ANSWER 3 GOES HERE'],
score: 5,
},
],
};
This structure allows you to organize your quiz questions by topics, making it easy to manage and maintain. You can create additional files for different quiz topics, and each file will export a topic object containing the details of that specific quiz.
/***************************** 31. PROJECT-ROOT-FOLDER/src/hooks/index.tsx ******************************/
The PROJECT-ROOT-FOLDER/src/hooks/index.tsx file is a simple export file that re-exports the functionality from other hook files. This is a common practice in JavaScript and TypeScript projects to provide a convenient way for other modules to import multiple hooks from a single entry point.
Here's a breakdown of the code:
// src/hooks/index.ts
// Import individual hooks
import useShuffleQuestions from './useShuffleQuestions';
import useTimer from './useTimer';
// Export the hooks to make them accessible from other modules
export { useShuffleQuestions, useTimer };
Now, when you want to use these hooks in other parts of your application, you can import them using the named exports from the index.ts file.
For example:
// Importing hooks in another module
import { useShuffleQuestions, useTimer } from '../hooks';
// Now you can use these hooks in your component
const MyComponent = () => {
const shuffledQuestions = useShuffleQuestions();
const { time, startTimer, stopTimer } = useTimer();
// ... rest of your component logic
};
This pattern provides a cleaner and more organized way to import multiple hooks from a specific directory in your project.
/***************************** 32. PROJECT-ROOT-FOLDER/src/hooks/useShuffleQuestions.ts ******************************/
The PROJECT-ROOT-FOLDER/src/hooks/useShuffleQuestions.ts file defines a custom hook named useShuffleQuestions that shuffles the array of questions when the current screen is QuizDetailsScreen.
Here's a breakdown of the code:
// src/hooks/UseShuffleQuestions.ts
import { useEffect } from "react";
import { useQuiz } from "../context/QuizContext";
import { ScreenTypes } from "../types";
import { shuffleArray } from "../utils/helpers";
// Custom hook to shuffle questions when the current screen is QuizDetailsScreen
export const useShuffleQuestions = () => {
const { setQuestions, currentScreen, questions } = useQuiz();
useEffect(() => {
if (currentScreen === ScreenTypes.QuizDetailsScreen) {
setQuestions(shuffleArray(questions));
}
}, [currentScreen, setQuestions, questions]);
};
export default useShuffleQuestions;
Explanation:
1. Import necessary dependencies and utilities.
2. Define the useShuffleQuestions custom hook.
3. Inside the hook, access the relevant data and functions from the useQuiz context.
4. Use the useEffect hook to perform side effects when the dependencies change.
5. Check if the current screen is QuizDetailsScreen.
6. If true, shuffle the array of questions using the shuffleArray utility function and update the questions using setQuestions.
This hook can be used in components that need to shuffle the questions based on the current screen. For example, you can use it in the QuizDetailsScreen component or any other component where you want to trigger the shuffle effect.
/***************************** 33. PROJECT-ROOT-FOLDER/src/hooks/useTimer.ts ******************************/
The PROJECT-ROOT-FOLDER/src/hooks/useTimer.ts file defines a custom hook named useTimer that manages the countdown timer for a quiz.
Here's an explanation of the code:
// src/hooks/useTimer.ts
import { Dispatch, SetStateAction, useEffect } from "react";
interface QuizDetails {
totalTime: number;
}
const useTimer = (
timer: number,
quizDetails: QuizDetails,
setEndTime: (time: number) => void,
setTimer: Dispatch<SetStateAction<number>>,
setShowTimerModal: (time: boolean) => void,
showResultModal: boolean
) => {
useEffect(() => {
// When the timer reaches 0
if (timer <= 0) {
const timeTaken = quizDetails.totalTime;
setEndTime(timeTaken);
setShowTimerModal(true);
setTimer(0);
}
}, [timer, quizDetails.totalTime, setEndTime, setShowTimerModal, setTimer]);
useEffect(() => {
// Update the timer every second
if (!showResultModal) {
const countTimer = setTimeout(() => {
setTimer((prevTimer) => prevTimer - 1);
}, 1000);
// Cleanup the timer when the component unmounts or the conditions change
return () => clearTimeout(countTimer);
}
}, [timer, setTimer, showResultModal]);
};
export default useTimer;
Explanation:
1. Import necessary dependencies.
2. Define the useTimer custom hook that takes several parameters for managing the timer.
3. Use the first useEffect to check if the timer has reached 0. If true, set the end time, show the timer modal, and reset the timer to 0.
4. Use the second useEffect to update the timer every second using setTimeout. The update is conditional based on whether the result modal is showing.
5. Clean up the timer when the component unmounts or when the conditions change.
This hook can be used in components where you need to manage the countdown timer for a quiz. Ensure that you pass the necessary parameters correctly when using this hook.
/***************************** 34. PROJECT-ROOT-FOLDER/src/styles/Breakpoints.ts ******************************/
The PROJECT-ROOT-FOLDER/src/styles/Breakpoints.ts file defines an interface Size and an object size containing breakpoint values for different screen sizes. It also exports a device object containing media query strings using these breakpoints.
Here's the code breakdown:
// src/styles/Breakpoints.ts
// Interface to define the breakpoint sizes
interface Size {
xs: string;
sm: string;
md: string;
lg: string;
xl: string;
xxl: string;
}
// Object containing the actual breakpoint sizes
const size: Size = {
xs: "400px", // for small screen mobile
sm: "600px", // for mobile screen
md: "900px", // for tablets
lg: "1280px", // for laptops
xl: "1440px", // for desktop / monitors
xxl: "1920px", // for big screens
};
// Export an object containing media query strings using the defined sizes
export const device = {
xs: `(max-width: ${size.xs})`,
sm: `(max-width: ${size.sm})`,
md: `(max-width: ${size.md})`,
lg: `(max-width: ${size.lg})`,
xl: `(max-width: ${size.xl})`,
xxl: `(max-width: ${size.xxl})`,
};
Explanation:
1. Size is an interface defining the different screen sizes (xs, sm, md, lg, xl, xxl) and their corresponding values.
2. The size object contains the actual values for each screen size.
3. The device object is exported, containing media query strings using the max-width property and the defined sizes. These media queries can be used in styled components to apply styles based on the screen size.
This is a common approach to managing breakpoints in responsive web design. You can use these media queries in your styled components to create responsive designs that adapt to different screen sizes.
/***************************** 35. PROJECT-ROOT-FOLDER/src/styles/fonts.module.css ******************************/
The PROJECT-ROOT-FOLDER/src/styles/fonts.module.css file contains @font-face declarations for the "Anek Malayalam" font family with different weights. These declarations are used to load the corresponding font files for various font weights from the specified paths. The font-display: swap; property is used to enable a font swap behavior, which means the browser will use a fallback font until the custom font is loaded.
Here's a breakdown of the file:
/* woff2: Super Modern Browsers */
/* woff: Modern Browsers */
@font-face {
font-family: 'Anek Malayalam';
font-style: normal;
font-weight: 100;
src: url('../assets/fonts/anek-malayalam/anek-malayalam-v4-malayalam-100.woff2') format('woff2'),
url('../assets/fonts/anek-malayalam/anek-malayalam-v4-malayalam-100.woff') format('woff');
font-display: swap;
}
/* Similar declarations for different font weights (200, 300, 400, 500, 600, 700, 800) */
/* Example for font-weight: 200 */
@font-face {
font-family: 'Anek Malayalam';
font-style: normal;
font-weight: 200;
src: url('../assets/fonts/anek-malayalam/anek-malayalam-v4-malayalam-200.woff2') format('woff2'),
url('../assets/fonts/anek-malayalam/anek-malayalam-v4-malayalam-200.woff') format('woff');
font-display: swap;
}
/* Additional declarations for other font weights */
/* Example for font-weight: 800 */
@font-face {
font-family: 'Anek Malayalam';
font-style: normal;
font-weight: 800;
src: url('../assets/fonts/anek-malayalam/anek-malayalam-v4-malayalam-800.woff2') format('woff2'),
url('../assets/fonts/anek-malayalam/anek-malayalam-v4-malayalam-800.woff') format('woff');
font-display: swap;
}
Make sure that the paths to the font files are correct relative to the location of this CSS file. This CSS file can be imported in your React components or global styles to apply the custom font styles.
/***************************** 36. PROJECT-ROOT-FOLDER/src/styles/Global.ts ******************************/
The PROJECT-ROOT-FOLDER/src/styles/Global.ts file contains the global styles for your React application using styled-components. It includes various styled components, such as GlobalStyles, Container, Box, PageCenter, Flex, CenterCardContainer, HighlightedText, LogoContainer, and ResizableBox.
Here's a summary of the styles:
1. GlobalStyles:
Imports the fonts.module.css content as global styles.
Sets box-sizing rules to border-box for all elements.
Defines base styling for HTML and body, including font size, font family, color, background, and line height.
Resets margin and padding for specific elements (h1 to dd).
Resets styles for button, ul, and ol.
Provides styling for links (a elements without a class).
Sets max-width for images and makes them block elements.
Inherits fonts for form elements (input, button, textarea, select).
Removes animations and transitions for users with reduced motion preferences.
2. Container:
Provides styling for a responsive container with a maximum width of 1360px and centered content.
3. Box:
Styled div with margin-top and optional flex right styling.
4. PageCenter:
Styled div for centering content on the page.
Supports light background and justification center options.
5. Flex:
Styled div for flex container with optional settings for centering, spacing between, and aligning to the end.
Supports custom gap property.
6. CenterCardContainer:
Styled div for a centered card container with specific dimensions and styling.
7. HighlightedText:
Styled span for highlighted text, with options for theme text or theme color.
8. LogoContainer:
Styled div for a centered logo container with optional styling.
9. ResizableBox:
Styled div with a customizable width.
These styles provide a consistent and responsive layout for your React application. They use the theme object for dynamic theming, making it easy to switch between light and dark themes. The device object from BreakPoints.ts is used to apply responsive styles based on different screen sizes.
/***************************** 37. PROJECT-ROOT-FOLDER/src/styles/styled.d.ts ******************************/
The PROJECT-ROOT-FOLDER/src/styles/styled.d.ts file is a TypeScript declaration file for extending the DefaultTheme in the styled-components library. It defines the structure of your theme object, specifying colors, fonts, shadows, paddings, margins, and other theme-related properties.
Here's a breakdown of the file:
// styled.d.ts
// Import original module declarations
import "styled-components";
// Define the theme interface
export interface Theme {
colors: {
// Color definitions
// ...
};
fonts: {
// Font definitions
// ...
};
shadows: {
// Shadow definitions
// ...
};
paddings: {
// Padding definitions
// ...
};
margins: {
// Margin definitions
// ...
};
}
// Extend the DefaultTheme interface from 'styled-components'
declare module "styled-components" {
export interface DefaultTheme extends Theme {}
}
In this file:
The Theme interface defines the structure of your theme object, which includes color definitions (colors), font definitions (fonts), shadow definitions (shadows), padding definitions (paddings), and margin definitions (margins).
The DefaultTheme interface is then extended from styled-components with your custom Theme interface. This ensures that the extended theme is available for use throughout your styled components.
This TypeScript declaration file allows you to use your custom theme properties with autocomplete and type checking when using styled-components in your application. The properties in the Theme interface correspond to the various theme properties used in your global styles and styled components.
/***************************** 38. PROJECT-ROOT-FOLDER/src/styles/Theme.ts ******************************/
The PROJECT-ROOT-FOLDER/src/styles/Theme.ts file defines two themes, 'light' and 'dark', with corresponding color schemes and styles. These themes are structured according to the Theme interface defined in the styled.d.ts file.
Let's break down the file:
// Import the Theme interface
import { Theme } from "./styled";
// Define themes using the Theme interface
export const themes: Record<string, Theme> = {
light: {
// Light theme properties
colors: {
// Color definitions
// ...
},
fonts: {
// Font definitions
// ...
},
shadows: {
// Shadow definitions
// ...
},
paddings: {
// Padding definitions
// ...
},
margins: {
// Margin definitions
// ...
},
},
dark: {
// Dark theme properties
colors: {
// Color definitions
// ...
},
fonts: {
// Font definitions
// ...
},
shadows: {
// Shadow definitions
// ...
},
paddings: {
// Padding definitions
// ...
},
margins: {
// Margin definitions
// ...
},
},
};
The Theme.ts file defines two themes, 'light' and 'dark', with corresponding color schemes and styles. These themes are structured according to the Theme interface defined in the styled.d.ts file.
Let's break down the structure:
// Import the Theme interface
import { Theme } from "./styled";
// Define themes using the Theme interface
export const themes: Record<string, Theme> = {
light: {
// Light theme properties
colors: {
// Color definitions
// ...
},
fonts: {
// Font definitions
// ...
},
shadows: {
// Shadow definitions
// ...
},
paddings: {
// Padding definitions
// ...
},
margins: {
// Margin definitions
// ...
},
},
dark: {
// Dark theme properties
colors: {
// Color definitions
// ...
},
fonts: {
// Font definitions
// ...
},
shadows: {
// Shadow definitions
// ...
},
paddings: {
// Padding definitions
// ...
},
margins: {
// Margin definitions
// ...
},
},
};
In each theme (light and dark), you have nested objects for colors, fonts, shadows, paddings, and margins. Each of these objects contains specific property-value pairs related to the respective theme category.
For example, within colors, you have properties like primaryText, secondaryText, etc., each representing a color used in your application. The same structure applies to other categories like fonts, shadows, paddings, and margins.
These theme objects can be easily accessed and switched between in your application, allowing you to have a consistent look and feel across different components based on the selected theme.
/***************************** 39. PROJECT-ROOT-FOLDER/src/types/index.ts ******************************/
The tPROJECT-ROOT-FOLDER/src/types/index.ts file defines various types and interfaces used in your application.
Let's break down the code:
import { Dispatch, SetStateAction } from "react";
import { Question } from "../data/QuizQuestions";
// Enum defining different screen types
export enum ScreenTypes {
SplashScreen,
QuizTopicsScreen,
QuizDetailsScreen,
QuestionScreen,
ResultScreen,
}
// Interface representing a question with additional properties
export interface QuestionTypes extends Question {
skipped?: boolean;
}
// Interface representing a result, extending the QuestionTypes interface
export interface Result extends QuestionTypes {
selectedAnswer: string[];
isMatch: boolean;
skipped?: boolean;
}
// Interface defining the context for the quiz
export type QuizContextTypes = {
currentScreen: ScreenTypes;
setCurrentScreen: Dispatch<SetStateAction<ScreenTypes>>;
quizTopic: string;
selectQuizTopic: (type: string) => void;
questions: QuestionTypes[];
setQuestions: Dispatch<SetStateAction<any[]>>;
result: Result[];
setResult: Dispatch<SetStateAction<any[]>>;
timer: number;
setTimer: Dispatch<SetStateAction<number>>;
endTime: number;
setEndTime: (type: number) => void;
quizDetails: {
totalQuestions: number;
totalScore: number;
totalTime: number;
selectedQuizTopic: string;
};
};
Here's a brief overview of the types and interfaces:
ScreenTypes: An enum representing different screen types in your application.
QuestionTypes: An interface extending the Question interface from your quiz data with an additional skipped property.
Result: An interface extending QuestionTypes with properties related to the result, such as selectedAnswer, isMatch, and skipped.
QuizContextTypes: An interface defining the context for the quiz, including information about the current screen, selected quiz topic, questions, results, timer, and quiz details.
These types and interfaces help maintain a clear and structured definition of the data and context used throughout your application. They are particularly useful when working with React state and context.
/***************************** 40. PROJECT-ROOT-FOLDER/src/utils/helpers.ts ******************************/
The PROJECT-ROOT-FOLDER/src/utils/helpers.ts file provides various utility functions used in your application.
Let's go through the code:
// Add leading zero to a number if it is less than 10
export const addLeadingZero = (number: number) => {
if (number > 9) {
return number;
} else {
return "0" + number;
}
};
// Utility function to format time in minutes:seconds
export function formatTime(time: number) {
const minutes = Math.floor(time / 60);
const seconds = time % 60;
return `${minutes}:${seconds.toString().padStart(2, "0")}`;
}
// Convert seconds to a formatted string (hours, minutes, seconds)
export const convertSeconds = (seconds: number): string => {
const hours = Math.floor(seconds / 3600);
const minutes = Math.floor((seconds % 3600) / 60);
const remainingSeconds = seconds % 60;
const hourString = hours > 0 ? `${hours} hour${hours > 1 ? "s" : ""}` : "";
const minuteString =
minutes > 0 ? `${minutes} minute${minutes > 1 ? "s" : ""}` : "";
const secondString =
remainingSeconds > 0
? `${remainingSeconds} second${remainingSeconds > 1 ? "s" : ""}`
: "";
if (hours > 0) {
return `${hourString} : ${minuteString || "0 minute"} ${
secondString && `: ${secondString}`
}`;
} else if (!hours && minutes > 0) {
return `${minuteString} ${secondString && `: ${secondString}`}`;
}
return secondString;
};
// Refresh the page
export const refreshPage = (): void => {
window.location.reload();
};
// Shuffle an array
export const shuffleArray = <T>(array: T[]): T[] => {
const shuffledArray = [...array];
for (let i = shuffledArray.length - 1; i > 0; i--) {
const j = Math.floor(Math.random() * (i + 1));
// Swap elements using array destructuring
[shuffledArray[i], shuffledArray[j]] = [shuffledArray[j], shuffledArray[i]];
}
return shuffledArray;
};
These utility functions handle tasks such as adding leading zeros to numbers, formatting time, converting seconds to a readable format, refreshing the page, and shuffling arrays. These functions are useful for various aspects of your application, providing a clean and modular way to perform common tasks.